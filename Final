# final. species specific on Italy for birds

# input data: - world AOH maps for Birds; - protected areas layer form WDPA, and IBAs from LIPU

# Step 0 : process and prepare input data (AOH and wdpa)
# step 1 : Common Conductance
# Step 2 : spSpecific Conductance and nodes
# Step 3 : connectivity
# Step 4 : overlapping



############################################ Step 0 ###############################################
#################### AOH ##################

# AOH downloaded from dryads how to obtain a folder of AOH cropped on Italian territory + transboundary buffer. 

# codice per filtrare i file AOH con extent europea e cropparli -> EU_final da cui partire per poi filtrare i vari paesi

### su locale

# from all -> intersected with ext(eu_admin_no_beyond.shp)
library(terra)
library(sf)
library(dplyr)
setwd("D:/")

eu <- vect("corridors/europe_admin_wgs/eu_admin_nobeyond_wgs.shp")
eu <- project(eu, "EPSG:4326")
crs(eu)
eu_extent <- ext(eu)

prova_crs <- rast("corridors/AOH/Extracted/Birds_migratory_accipitriformes/Accipiter_badius_B.tif")
crs(prova_crs)


base_path <- "corridors/AOH/Extracted/"
ordini <- list.dirs(base_path, recursive = FALSE)
rasters_to_keep <- list()

for (ordine in ordini) {
  
  raster_files <- list.files(ordine, pattern = "\\.tif$", full.names = TRUE)
  
  for (raster_file in raster_files) {
    
    r <- rast(raster_file)
    
    if (relate(ext(r), eu_extent, "intersects")) {
      rasters_to_keep <- append(rasters_to_keep, raster_file)
    }
  }
}

print(rasters_to_keep)

# cosi ne seleziona 1020.  



##### croppo i file all'extent eu

output_folder <- "corridors/AOH/EU_final/"
dir.create(output_folder, recursive =T)

europe_mask <- vect("corridors/europe_admin_wgs/eu_admin_nobeyond_wgs.shp")

# Funzione per processare e salvare un singolo raster
process_raster <- function(raster_path, mask, output_folder) {
  tryCatch({
    # Carica il raster
    r <- rast(raster_path)
    
    # Croppa e maschera il raster
    cropped_raster <- crop(r, mask, snap = "out")  # Croppa il raster
    masked_raster <- mask(cropped_raster, mask)    # Applica la maschera
    
    # Definisci il percorso di salvataggio
    output_path <- file.path(output_folder, basename(raster_path))
    
    # Salva il raster clippato
    writeRaster(masked_raster, output_path, overwrite = TRUE)
    
    # Rimuovi il raster dall'ambiente per liberare memoria
    rm(r, cropped_raster, masked_raster)
    gc()  # Richiama la garbage collection per liberare memoria
    
    message("Processed: ", raster_path)
  }, error = function(e) {
    message("Error processing: ", raster_path, " - ", e)
  })
}

# Applica la funzione a tutti i file raster
lapply(rasters_to_keep, process_raster, mask = europe_mask, output_folder = output_folder)




## su server


# filtro AOH_EU == 1 per paese. ex ita
library(terra)
library(raster)

#setwd("/media/r_projects/paola.merelli2/assegno_prin/IBAs/")

input_folder <- "EU_final/"  
output_folder_filtered <- "IT_AOH_filtered"
output_folder_cropped <- "IT_AOH_cropped"
output_folder_final <- "IT_AOH_final_tr"
#dir.create(output_folder_filtered, recursive = F)

num_cores <- 8
log_file <- "processing_log.txt"

log_message <- function(msg) {
  cat(msg, "\n")
  write(msg, file = log_file, append = TRUE)
}

AOH_filtering_by_extent <- function(raster_files, ita_vect, log_file = NULL) {
  rasters_to_keep <- list()
  ita_proj <- terra::project(ita_vect, "EPSG:4326")
  ita_ext <- ext(ita_proj)
  ita_crs <- crs(ita_proj)
  
  log_message <- function(msg) {
    cat(msg, "\n")
    if (!is.null(log_file)) {
      write(msg, file = log_file, append = TRUE)
    }
  }
  
  for (i in seq_along(raster_files)) {
    file <- raster_files[i]
    log_message(paste0("[", i, "/", length(raster_files), "] Checking extent of: ", basename(file)))
    
    # Carica solo metadati
    r_meta <- rast(file, lyrs = 1)
    
    # Verifica CRS
    if (!same.crs(ita_crs, crs(r_meta))) {
      log_message("  ✗ Skipped: CRS mismatch")
      next
    }
    
    # Verifica sovrapposizione geografica
    if (!relate(ext(r_meta), ita_ext, "intersects")) {
      log_message("  ✗ Skipped: no intersection with Italy extent")
      next
    }
    
    log_message("  ✓ Kept: intersects with Italy extent")
    rasters_to_keep <- c(rasters_to_keep, file)
  }
  
  return(rasters_to_keep)
}

all_rasters <- list.files(input_folder, pattern = "\\.tif$", full.names = TRUE)
#all_rasters <- all_rasters[1:5]
ita_vect <- vect("ita.shp")
rasters_to_keep <- AOH_filtering_by_extent(all_rasters, ita_vect)


input_folder <- "IT_AOH_filtered/"  
output_folder <- "IT_AOH_cropped/"  
num_cores <- 4
raster_files <- list.files(input_folder, pattern = "\\.tif$", full.names = TRUE)

file_chunks <- split(raster_files, cut(seq_along(raster_files), num_cores, labels = FALSE))

process_chunk <- function(chunk_files) {
  library(terra)
  ita_vect <- terra::vect("ita.shp")
  ita_merged <- aggregate(ita_vect)
  ita_tr <- buffer(ita_merged, width = 100000)
  template <- rast(ext = ext(ita_tr), resolution = c(100, 100))
  crs(template) <- "EPSG:3035"
  ita_mask <- terra::project(ita_tr, "EPSG:4326")
  template_wgs <- project(template, "EPSG:4326")
  template_wgs[] <- 1
  
  results <- character()
  
  for (raster_file in chunk_files) {
    result <- tryCatch({
      r <- terra::rast(raster_file)
      r_resampled <- terra::resample(r, template_wgs)
      r_extended <- terra::extend(r_resampled, ita_mask)
      r_cropped <- terra::crop(r_extended, ita_mask)
      r_masked <- terra::mask(r_cropped, ita_mask)
      r_final <- terra::classify(r_masked, rbind(c(-Inf, 0, NA), c(1, 1, 1), c(1.0001, Inf, NA)))
      terra::coltab(r_final) <- NULL
      output_file <- file.path(output_folder, basename(raster_file))
      terra::writeRaster(r_final, output_file, overwrite = TRUE, datatype = "INT1U")
      
      r <- NULL
      r_resampled <- NULL
      r_masked <- NULL
      r_cropped <- NULL
      r_extended <- NULL
      r_final <- NULL
      gc()
      
      paste("Successfully processed:", raster_file)
    }, error = function(e) {
      paste("Error processing", raster_file, ":", e$message)
    })
    
    results <- c(results, result)
  }
  
  return(results)
}
cl <- makeCluster(num_cores)

clusterExport(cl, c("output_folder", "process_chunk"))
clusterEvalQ(cl, library(terra))

all_results <- parLapply(cl, file_chunks, process_chunk)
stopCluster(cl)
all_results <- unlist(all_results)


############ uniformo BNR

raster_files <- list.files("IT_AOH_cropped/", pattern = "\\.tif$", full.names = TRUE)
species_names <- unique(gsub("_[NRB]\\.tif$|\\.tif$", "", basename(raster_files)))
output_folder <- "IT_AOH_final_trans/"
num_cores <- 8
species_chunks <- split(species_names, cut(seq_along(species_names), num_cores, labels = FALSE))

process_species_chunk <- function(species_chunk) {
  library(terra)
  
  results <- character()
  
  for (species in species_chunk) {
    result <- tryCatch({
      species_rasters <- raster_files[grepl(paste0("^", species, "(_[NRB])?\\.tif$"), basename(raster_files))]
      
      if (length(species_rasters) > 1) {
        rasters <- lapply(species_rasters, rast)
        merged_raster <- Reduce(function(x, y) sum(x, y, na.rm = TRUE), rasters)
        merged_raster[merged_raster > 1] <- 1
        
      } else if (length(species_rasters) == 1) {
        merged_raster <- rast(species_rasters)
      } else {
        return(paste("No rasters found for species:", species))
      }
      
      output_file <- file.path(output_folder, paste0(species, ".tif"))
      writeRaster(merged_raster, output_file, overwrite = TRUE)
      
      merged_raster <- NULL
      gc()
      
      paste("Successfully processed species:", species)
    }, error = function(e) {
      paste("Error processing species:", species, "-", e$message)
    })
    
    results <- c(results, result)
  }
  
  return(results)
}
cl <- makeCluster(num_cores)
clusterExport(cl, c("raster_files", "output_folder", "process_species_chunk"))
all_results <- parLapply(cl, species_chunks, process_species_chunk)
stopCluster(cl)


# vedi "all" per analisi su n aree protette per specie, % di copertura per specie





###################  WDPA ##########################

wdpa_dir <- "directory_wdpa_ita_cleaned"
wdpa_ita <- vect(wdpa_dir)
wdpa_ita <- makeValid(wdpa_ita)
crs(wdpa_ita)

ita_tr <- terra::project(ita_tr, crs("EPSG:3035"))
ita_tr <- makeValid(ita_tr)

wdpa_tr <- crop(wdpa_ita, ita_tr)
wdpa_tr <- mask(wdpa_tr, ita_tr)

plot(wdpa_tr)

names(wdpa_tr)

wdpa_filtered <- wdpa_tr[!(wdpa_10_trans$MARINE == "marine" | 
                                   grepl("Birds Directive", wdpa_tr$DESIG_E) | 
                                   grepl("Habitats Directive", wdpa_tr$DESIG_E))]

wdpa_sf <- st_as_sf(wdpa_filtered)
wdpa_sf$group_id <- 1:nrow(wdpa_sf)
dissolve_connected_components <- function(sf_layer) {
  neighbors <- st_touches(sf_layer)
  
  group <- rep(NA_integer_, length(neighbors))
  current_group <- 1
  
  for (i in seq_along(neighbors)) {
    if (is.na(group[i])) {
      to_visit <- c(i)
      while (length(to_visit) > 0) {
        idx <- to_visit[1]
        to_visit <- to_visit[-1]
        if (is.na(group[idx])) {
          group[idx] <- current_group
          new_neighbors <- neighbors[[idx]]
          to_visit <- c(to_visit, new_neighbors[is.na(group[new_neighbors])])
        }
      }
      current_group <- current_group + 1
    }
  }
  
  cat("Totale gruppi trovati:", length(unique(group)), "\n")
  sf_layer$group_id <- group
  
  dissolved <- sf_layer %>%
    group_by(group_id) %>%
    summarise(geometry = st_union(geometry), .groups = "drop")
  
  return(dissolved)
}

wdpa_dissolved <- dissolve_connected_components(wdpa_sf)

st_write(wdpa_dissolved, "prenodi/prova_transboundary/wdpa_nodi.shp", overwrite= T)

############################################ Step 1 : Common conductance #####################################################
############################ AOH Richness

raster_files <- list.files("IT_AOH_final/", pattern = "\\.tif$", full.names = TRUE)

template_file <- rast(raster_files[1])
template_file[] <- 0
plot(template_file)

num_cores <- 8
cl <- makeCluster(num_cores)
registerDoParallel(cl)

chunk_size <- ceiling(length(raster_files) / num_cores)
file_chunks <- split(raster_files, ceiling(seq_along(raster_files) / chunk_size))

temp_dir <- "temp_rasters"
#dir.create(temp_dir, showWarnings = FALSE)

partial_results <- foreach(i = seq_along(file_chunks), 
                           .packages = c("terra")) %dopar% {
                            chunk <- file_chunks[[i]]
                             
                            local_template <- rast(chunk[1])
                            local_template <- 0
                            partial_sum <- local_template
                            
                            for (file in chunk) {
                               aoh_raster <- rast(file)
                               aoh_raster[is.na(aoh_raster)] <- 0
                               partial_sum <- partial_sum + aoh_raster
                               rm(aoh_raster)
                               gc()
                             }
                             
                             temp_file <- file.path(temp_dir, paste0("partial_", i, ".tif"))
                             writeRaster(partial_sum, temp_file, overwrite = TRUE)
                             return(temp_file)
                           }

stopCluster(cl)
for (temp_file in partial_results) {
  if (file.exists(temp_file)) {
    partial_raster <- rast(temp_file)
    AOH_richness <- template_file + partial_raster
    rm(partial_raster)
    file.remove(temp_file)
    gc()
  } else {
    warning(paste("File not found:", temp_file))
  }
}
unlink(temp_dir, recursive = TRUE)

plot(AOH_richness)
head(AOH_richness)


min_r <- min(values(AOH_richness), na.rm = TRUE)  
max_r <- max(values(AOH_richness), na.rm = TRUE)  
min_scale <- 0
max_scale <- 100

con_rescaling <- function(richness, min_r, max_r, min_res, max_res) {
  return(((richness - min_r) / (max_r - min_r)) * (max_res - min_res) + min_res)
}

AOH_richness$conductance <- con_rescaling(values(AOH_richness), 
                                         min_r, max_r, 
                                         min_scale, max_scale)

plot(AOH_richness$conductance)

AOH_richness <- AOH_richness[["conductance"]]

#writeRaster(AOH_richness, "final/con_AOH_richness.tif")






############################### res_rli


species_data <- read.csv("final/species_iucn.csv") 
species_data$Scientific.name <- gsub(" ", "_", species_data$Scientific.name)
iucn_weights <- c("LC" = 0, "NT" = 1, "VU" = 2, "EN" = 3, "CR" = 4, "EX" = 5)
species_data$weight <- iucn_weights[species_data$RL.Category]

num_cores <- detectCores() - 8
cl <- makeCluster(num_cores)
registerDoParallel(cl)

# Dividi i file in chunks
chunk_size <- ceiling(length(raster_files) / num_cores)
file_chunks <- split(raster_files, ceiling(seq_along(raster_files) / chunk_size))

# Crea cartella temporanea
temp_dir <- "temp_rasters_iucn"
dir.create(temp_dir, showWarnings = FALSE)

# Elabora i chunks in parallelo
partial_results <- foreach(i = seq_along(file_chunks), 
                           .packages = c("terra", "tools"),
                           .export = c("species_data", "iucn_weights", "temp_dir")) %dopar% {
                             
                             chunk <- file_chunks[[i]]
                             
                             # Crea template dal primo file del chunk
                             template_file <- rast(chunk[1])
                             
                             # Inizializza i raster per questo worker
                             weight_sum <- template_file
                             species_count <- template_file
                             values(weight_sum) <- 0
                             values(species_count) <- 0
                             
                             for (file in chunk) {
                               species_name <- file_path_sans_ext(basename(file))
                               
                               # Elabora solo se la specie è nei dati IUCN
                               weight_idx <- which(species_data$Scientific.name == species_name)
                               
                               if (length(weight_idx) == 1) {
                                 weight <- species_data$weight[weight_idx]
                                 
                                 # Carica e processa il raster
                                 aoh_raster <- rast(file)
                                 aoh_raster[is.na(aoh_raster)] <- 0
                                 
                                 # Aggiorna i conteggi
                                 weight_sum <- weight_sum + (aoh_raster * weight)
                                 species_count <- species_count + aoh_raster
                                 
                                 # Pulizia memoria
                                 rm(aoh_raster)
                                 gc()
                               }
                             }
                             
                             # Salva i risultati parziali
                             weight_file <- file.path(temp_dir, paste0("weight_", i, ".tif"))
                             count_file <- file.path(temp_dir, paste0("count_", i, ".tif"))
                             
                             writeRaster(weight_sum, weight_file, overwrite = TRUE)
                             writeRaster(species_count, count_file, overwrite = TRUE)
                             
                             return(list(weight_file = weight_file, count_file = count_file))
                           }

stopCluster(cl)

sum_weights_raster <- template_file
species_count_raster <- template_file
for (result in partial_results) {
  if (file.exists(result$weight_file)) {
    partial_weight <- rast(result$weight_file)
    sum_weights_raster <- sum_weights_raster + partial_weight
    rm(partial_weight)
    file.remove(result$weight_file)
  } else {
    warning(paste("Weight file not found:", result$weight_file))
  }
  
  if (file.exists(result$count_file)) {
    partial_count <- rast(result$count_file)
    species_count_raster <- species_count_raster + partial_count
    rm(partial_count)
    file.remove(result$count_file)
  } else {
    warning(paste("Count file not found:", result$count_file))
  }
  
  gc()
}
unlink(temp_dir, recursive = TRUE)

plot(sum_weights_raster)
plot(species_count_raster)
max_weight_raster <- species_count_raster * 5  
rli_raster <- 1 - (sum_weights_raster / max_weight_raster)
plot(rli_raster)
rli_raster[is.na(rli_raster)] <- NA

min_r <- min(values(rli_raster), na.rm = TRUE)  
max_r <- max(values(rli_raster), na.rm = TRUE)  
min_scale <- 0
max_scale <- 100

inv_con_rescaling <- function(richness, min_r, max_r, min_res, max_res) {
  return(((max_r - richness) / (max_r - min_r)) * (max_res - min_res) + min_res)
}

rli_raster$conductance <- inv_con_rescaling(values(rli_raster), 
                                          min_r, max_r, 
                                          min_scale, max_scale)

plot(rli_raster$conductance)

rli_raster <- rli_raster[["conductance"]]

#writeRaster(rli_raster, "con_RLI_Index.tif", overwrite = TRUE)




################################ res_dpa

ita <- vect(ita_mask_path)
wdpa <- vect("dir_wdpa_ita_cleaned")
wdpa <- makeValid(wdpa)
crs(wdpa)

ita_tr <- terra::project(ita_tr, crs("EPSG:3035"))
ita_tr <- makeValid(ita_tr)

wdpa_tr <- crop(wdpa, ita_tr)
wdpa_tr <- mask(wdpa_tr, ita_tr)

wdpa_filtered <- wdpa_tr[!(wdpa_10_trans$MARINE == "marine")]

iba <- vect("final/IBAsGlobal_2024_September_03/IBAsGlobal_2024_September_POL_03.shp")
iba_ita <- crop(iba, ita_tr)
iba_ita <- mask(iba_ita, ita_tr)
iba_ita <- terra::project(iba_ita, crs("EPSG:3035"))
ita_pa <- rbind(wdpa_filtered, iba_ita)
template_file <- terra::project(template_file, crs("EPSG:3035"))
ita <- terra::project(ita, crs("EPSG:3035"))
ita_raster <- rasterize(ita, template_file, field = 1)
crs(ita_raster)
ita_pa_raster <- rasterize(ita_pa, template_file, field = 1)
plot(ita_pa_raster)
res_dpa <- terra::distance(ita_pa_raster)
res_dpa <- mask(res_dpa, ita_raster)
res_dpa <- res_dpa / 1000
plot(res_dpa)

min_d <- min(values(res_dpa), na.rm = TRUE)  
max_d <- max(values(res_dpa), na.rm = TRUE) 
min_scale2 <- 0
max_scale2 <- 100


inv_con_rescaling <- function(distance, min_d, max_d, min_res, max_res) {
  return(((max_d - distance) / (max_d - min_d)) * (max_res - min_res) + min_res)
}

res_dpa$conductance <- inv_con_rescaling(values(res_dpa), 
                                            min_d, max_d, 
                                            min_scale2, max_scale2)

res_dpa <- res_dpa[["conductance"]]
res_dpa <- terra::project(res_dpa, crs("EPSG:4326))
plot(res_dpa)
#writeRaster(res_dpa, "res_dpa.tif")




############################## con_common

#con_dpa <- rast("res_dpa.tif")
#con_richness <- rast("con_AOH_richness.tif")
#con_rli <- rast("con_RLI_Index.tif")
#ita_mask_path <- "prenodi/prova_transboundary/ita_30_trans_wgs.shp"
#ita <- vect(ita_mask_path)
#ita_tr <- buffer(ita, width = 1000000)


con_richness <- crop(con_richness, ita_tr)
con_richness <- mask(con_richness, ita_tr)

con_rli[is.na(con_rli)] <- 0
con_rli <- crop(con_rli, ita_tr)
con_rli <- mask(con_rli, ita_tr)

con_dpa <- crop(con_dpa, ita_tr)
con_dpa <- mask(con_dpa, ita_tr)

ext(con_dpa) <- ext(con_richness)
con_dpa <- resample(con_dpa, con_richness)
con_common <- con_richness + con_rli + con_dpa
writeRaster(con_common, "...")
plot(con_common)





############################################ Step 2 : spSpecific Conductance and nodes ###########################################
library(future)
library(furrr)

raster_files <- list.files("IT_AOH_final/", pattern = "\\.tif$", full.names = TRUE)
protected_areas <- vect("SCB/wdpa_nodi_final_30_tr.shp")
test <- rast(raster_files[1])

protected_areas <- terra::project(protected_areas, crs(test))
crs(protected_areas) == crs(test)
plot(protected_areas)
plot(test, add = T)

temp_pa_file <- tempfile(fileext = ".shp")
writeVector(protected_areas, temp_pa_file)

process_file <- function(file_path) {
  tryCatch({
    r <- rast(file_path)
    extracted <- extract(r, protected_areas, touches = TRUE)
    
    # Count protected areas with habitat (value = 1)
    count <- sum(
      tapply(extracted[, 2], extracted[, 1], function(values) any(values == 1, na.rm = TRUE))
    )
    
    return(count)
  }, error = function(e) {
    cat("Error processing", file_path, ":", conditionMessage(e), "\n")
    return(NA)
  })
}

cl <- makeCluster(10)
clusterExport(cl, c("temp_pa_file"))
clusterEvalQ(cl, {
  library(terra)
  protected_areas <- vect(temp_pa_file)
  NULL
})

results <- parSapply(cl, raster_files, process_file)
stopCluster(cl)

# Create final dataframe
percent_coverage_df <- data.frame(
  species = basename(raster_files),
  total_protected_areas = results
)

# Check result
print(head(percent_coverage_df))

nodes_df <- percent_coverage_df
nodes_df <- nodes_df %>%
  arrange(total_protected_areas)
#write.csv(nodes_df, "SCB/nodes_df.csv")

sp_list <- nodes_df["species"]
sp_list <- sp_list[2:51,]
head(sp_list)



source_folder <- "IT_AOH_final_trans/"
dest_folder <- "SCB/AOH/"
dir.create(dest_folder, recursive = TRUE)
all_files <- list.files(source_folder, full.names = FALSE)

matching_files <- all_files[all_files %in% sp_list]

for (file in matching_files) {
  source_path <- file.path(source_folder, file)
  dest_path <- file.path(dest_folder, file)
  
  file.copy(source_path, dest_path, overwrite = FALSE)
  cat("Copied:", file, "\n")
}




aoh_folder <- "SCB/AOH/"
raster_files <- list.files(aoh_folder, pattern = "\\.tif$", full.names = TRUE)
ita <- vect("SCB/ita_30_trans_wgs.shp")
con_common <- rast("SCB/con_common_trans_30.tif")

wdpa_nodi <- vect("SCB/wdpa_nodi_final_30_tr.shp") %>% terra::project(crs(ita))


########################################################################################################
wdpa_con <- vect("SCB/wdpa_con_final_30_tr.shp") %>% terra::project(crs(ita))

wdpa_con$conductance <- ifelse(grepl("National Park", wdpa_con$DESIG_E), 80,
                               ifelse(grepl("Regional/Provincial Nature Park", wdpa_con$DESIG_E), 60, 20))

template <- rast(raster_files[1])
pa_raster <- rasterize(wdpa_con, template, field = "conductance", touches = TRUE)
pa_raster[is.na(pa_raster)] <- 0
pa_raster <- pa_raster["conductance"]
pa_raster <- crop(pa_raster, ita) %>% mask(ita)

iba <- vect("final/IBAsGlobal_2024_September_03/IBAsGlobal_2024_September_POL_03.shp") %>%
  crop(ita) %>%
  mask(ita) %>% 
  makeValid()


iba$conductance <- 40
iba_raster <- rasterize(iba, template, field = "conductance", touches = TRUE)  

pa_raster <- ifel(pa_raster < 40 & !is.na(iba_raster), 40, pa_raster)
pa_raster <- pa_raster["conductance"]
#writeRaster(pa_raster, "SCB/pa_raster.tif")
#writeRaster(template, "SCB/template.tif", overwrite=TRUE)

#################################################################################################################

raster_files <- list.files("SCB/AOH/", full.names = TRUE)

process_species_data <- function(raster_path) {
  library(terra)
  library(sf)
  library(tools)
  
  species_name <- file_path_sans_ext(basename(raster_path))
  
  res_AOH_sp <- rast(raster_path)
  ita <- vect("SCB/ita_30_trans_wgs.shp")
  con_common <- rast("SCB/con_common_trans_30.tif")
  wdpa_nodi <- vect("SCB/wdpa_nodi_final_30_tr.shp") %>% terra::project(crs(ita))
  pa_raster <- rast("SCB/pa_raster.tif")
  template <- rast("SCB/template.tif")
  
  extracted <- terra::extract(res_AOH_sp, wdpa_nodi, touches = TRUE)
  protected_ids <- unique(extracted[extracted[, 2] == 1, 1])
  overlapping_areas <- wdpa_nodi[protected_ids, ]
  
  if (nrow(overlapping_areas) > 0) {
    centroidi <- centroids(overlapping_areas)
    centroidi_vals <- terra::extract(ita, centroidi)
    valid_centroidi <- !is.na(centroidi_vals[, 2])
    centroidi <- centroidi[valid_centroidi, ]
    
    nodi_sf <- st_as_sf(centroidi)
    dir.create("SCB/res_rasters/", showWarnings = FALSE, recursive = TRUE)
    st_write(nodi_sf, paste0("SCB/res_rasters/nodi_", species_name, ".shp"), delete_dsn = TRUE)
    
    overlapping_areas$conductance <- 100
    nodi_raster <- rasterize(overlapping_areas, template, field = "conductance", touches = TRUE)
    con_AOH_sp <- ifel(is.na(res_AOH_sp), 0, 100)
    con_pa_species <- ifel(!is.na(nodi_raster), 100, pa_raster)
    con_sp_final <- con_common + con_pa_species + con_AOH_sp
    
    con_sp_final <- crop(con_sp_final, ita)
    con_sp_final <- mask(con_sp_final, ita)
    
    writeRaster(con_sp_final, filename = paste0("SCB/res_rasters/con_", species_name, ".tif"), overwrite = TRUE)
    
    return(TRUE)
  } else {
    return(FALSE)
  }
}

# E poi parallelizzi così:
plan(multisession, workers = 5)
results <- future_map(raster_files, process_species_data, .progress = TRUE)





####################################### mapping sp-specific corridors

process_species_paths <- function(species_name) {
  message("Processing species: ", species_name)
  
  conductance_path <- paste0("SCB/res_rasters/con_", species_name, ".tif")
  nodes_path <- paste0("SCB/res_rasters/nodi_", species_name, ".shp")
  
  if (!file.exists(conductance_path) || !file.exists(nodes_path)) {
    message("Missing files for species: ", species_name)
    return(NULL)
  }
  
  # Load and process data
  conductance <- terra::rast(conductance_path)
  values(conductance)[values(conductance) == 0] <- 1e-10
  p <- terra::vect(nodes_path)
  
  p <- terra::project(p, "EPSG:3035")
  conductance <- terra::project(conductance, "EPSG:3035")
  
  conductance_lowres <- terra::aggregate(conductance, fact=3, fun="min")
  conductance_lowres <- raster(conductance_lowres)
  tr_low <- transition(conductance_lowres, mean, directions = 4)
  tr_low <- geoCorrection(tr_low)
  gc()
  
  conductance <- raster(conductance)
  tr_high <- transition(conductance, mean, directions = 4)
  tr_high <- geoCorrection(tr_high)
  gc()
  message("Trasnition calculated for species: ", species_name)
  
  p_coords <- as.matrix(terra::crds(p))
  
  cost_matrix_low <- costDistance(tr_low, p_coords)
  max_val <- max(cost_matrix_low[is.finite(cost_matrix_low)], na.rm = TRUE)
  cost_matrix_low[!is.finite(cost_matrix_low)] <- max_val * 10
  message("Cost matrix calculated for species: ", species_name)
  gc()
  
  calculate_mst <- function(cost_matrix) {
    n <- nrow(cost_matrix)
    parent <- integer(n)
    key <- rep(Inf, n)
    included <- logical(n)
    key[1] <- 0
    parent[1] <- -1
    for(count in 1:(n-1)) {
      min_index <- which.min(ifelse(included, Inf, key))
      included[min_index] <- TRUE
      for(v in 1:n) {
        if(!included[v] && cost_matrix[min_index, v] < key[v]) {
          parent[v] <- min_index
          key[v] <- cost_matrix[min_index, v]
        }
      }
    }
    return(parent)
  }
  
  mst_parent <- calculate_mst(as.matrix(cost_matrix_low))
  
  temp_dir <- tempdir()
  p_file <- file.path(temp_dir, paste0("p_", species_name, ".rds"))
  tr_high_file <- file.path(temp_dir, paste0("tr_high_", species_name, ".rds"))
  
  saveRDS(p, p_file)
  saveRDS(tr_high, tr_high_file)
  
  indices <- 2:length(mst_parent)
  
  n_cores <- 3
  cl <- makeCluster(n_cores)
  registerDoParallel(cl)
  
  message("Processing shortestPath for species: ", species_name)
  
  all_paths <- foreach(i = indices, .packages = c("terra", "sf", "gdistance", "raster")) %dopar% {
    p <- readRDS(p_file)
    tr_high <- readRDS(tr_high_file)
    
    from_idx <- mst_parent[i]
    to_idx <- i
    if (from_idx < 1) return(NULL)
    
    # Get coordinates
    from_coords <- terra::crds(p[from_idx, ], df = TRUE)
    to_coords <- terra::crds(p[to_idx, ], df = TRUE)
    
    # Convert to cells
    from_cell <- raster::cellFromXY(raster(tr_high), from_coords)
    to_cell <- raster::cellFromXY(raster(tr_high), to_coords)
    
    # Get xy coordinates from cells
    from_xy <- raster::xyFromCell(raster(tr_high), from_cell)
    to_xy <- raster::xyFromCell(raster(tr_high), to_cell)
    
    path <- tryCatch({
      shortestPath(tr_high, from_xy, to_xy, output = "SpatialLines")
    }, error = function(e) return(NULL))
    gc()
    
    if (is.null(path)) return(NULL)
    
    path_sf <- tryCatch({
      sf_path <- st_as_sf(path)
      if (any(!is.finite(st_bbox(st_as_sfc(sf_path))))) {
        return(NULL)
      }
      sf_path
    }, error = function(e) {
      return(NULL)
    })
    
    return(path_sf)
  }
  
  stopCluster(cl)
  gc()
  unlink(p_file)
  unlink(tr_high_file)
  
  all_paths <- all_paths[!sapply(all_paths, is.null)]
  if (length(all_paths) > 0) {
    all_paths_combined <- tryCatch({
      do.call(rbind, all_paths)
    }, error = function(e) {
      message("Error combining paths: ", e$message)
      return(NULL)
    })
    
    if (!is.null(all_paths_combined) && nrow(all_paths_combined) > 0) {
      out_dir <- "SCB/paths"
      if (!dir.exists(out_dir)) {
        dir.create(out_dir, recursive = TRUE)
      }
      
      out_path <- paste0(out_dir, "/paths_", species_name, ".shp")
      st_write(all_paths_combined, out_path, delete_layer = TRUE, quiet = TRUE)
      message("Saved: ", out_path)
      return(TRUE)
    } else {
      message("No valid paths to combine for: ", species_name)
    }
  } else {
    message("No valid paths for: ", species_name)
  }
  return(FALSE)
  gc()
}


shp_files <- list.files("SCB/res_rasters/", pattern = "^nodi_.*\\.shp$", full.names = FALSE)
shp_files <- shp_files[2:5]  # Limit to first 10 species
species_names <- gsub("^nodi_(.*)\\.shp$", "\\1", shp_files)

results <- sapply(species_names, process_species_paths)




####################################################################################
                                overlap analysis
####################################################################################

shp_folder <- "SCB/paths8/"
output_folder <- "SCB/results/"
dir.create(output_folder)

shapefile_paths <- list.files(path = shp_folder, 
                              pattern = "\\.shp$", 
                              full.names = TRUE)

process_species <- function(shapefile_path) {
  file_name <- basename(shapefile_path)
  species_name <- gsub("paths_(.+)\\.shp$", "\\1", file_name)
  
  paths <- st_read(shapefile_path, quiet = TRUE)
  paths <- st_make_valid(paths)
  
  st_crs(paths) <- 3035
  paths_projected <- st_transform(paths, 3035)
  paths_projected <- st_make_valid(paths_projected)
  paths_projected <- st_cast(paths_projected, "MULTILINESTRING")
  
  if (nrow(paths_projected) > 0) {
    # Create union and buffer
    paths_union <- st_union(paths_projected)
    paths_union <- st_make_valid(paths_union)
    
    buffer <- st_buffer(paths_union, dist = 500)
    buffer <- st_make_valid(buffer)
    
    return(list(species = species_name, buffer = buffer))
  }
  
  return(NULL)
}


species_buffers <- lapply(shapefile_paths, process_species)
species_buffers <- species_buffers[!sapply(species_buffers, is.null)]
species_names <- sapply(species_buffers, function(x) x$species)
buffer_list <- lapply(species_buffers, function(x) x$buffer)

all_buffers <- do.call(rbind, lapply(seq_along(buffer_list), function(i) {
  st_sf(species = species_names[i], geometry = buffer_list[[i]])
}))

bbox <- st_bbox(all_buffers)
resolution <- c(100, 100)

library(terra)
template_raster <- rast(xmin=bbox[1], xmax=bbox[3], 
                        ymin=bbox[2], ymax=bbox[4], 
                        resolution=resolution, 
                        crs=st_crs(all_buffers)$wkt)

corridor_rasters <- list()
for(i in 1:nrow(all_buffers)) {
  corridor <- all_buffers[i, ]
  species_name <- species_names[i]
  corridor_vect <- vect(corridor)
  corridor_rast <- rasterize(corridor_vect, template_raster, field=1, background=0)
  
  crs(corridor_rast) <- "EPSG:3035"
  
  corridor_rasters[[i]] <- corridor_rast
  
  writeRaster(corridor_rast, file.path(output_folder, paste0(species_name, "_corridor_raster.tif")), overwrite=TRUE)

  gc()
}

raster_folder <- "SCB/results/"
raster_files <- list.files(path = raster_folder, 
                           pattern = "^paths8.*\\.(tif|tiff)$", 
                           full.names = TRUE)

check_raster_info <- function(raster_file) {
  # Carica solo i metadati del raster (senza caricare i dati)
  r_info <- rast(raster_file)
  
  return(list(
    filename = raster_file,
    name = tools::file_path_sans_ext(basename(raster_file)),
    crs = crs(r_info),
    ext = ext(r_info),
    res = res(r_info)
  ))
}

raster_info <- lapply(raster_files, check_raster_info)

create_raster_stack <- function(files = raster_files, info = raster_info, chunk_size = 5) {
  total_files <- length(files)
  final_stack <- NULL
  for (i in seq(1, total_files, by = chunk_size)) {
      end_idx <- min(i + chunk_size - 1, total_files)
      chunk_files <- files[i:end_idx]
      chunk_info <- if (!is.null(info)) info[i:end_idx] else NULL
      
      print(paste("Elaborazione chunk", ceiling(i/chunk_size), "di", ceiling(total_files/chunk_size),
                  "(files", i, "-", end_idx, ")"))
      
      # Crea un raster list temporaneo per questo chunk
      temp_list <- lapply(chunk_files, function(x) {
        r <- rast(x)
        return(r)
      })
      
      # Assegna nomi ai raster
      if (!is.null(chunk_info)) {
        names_list <- sapply(chunk_info, function(x) x$name)
        names(temp_list) <- names_list
      } else {
        names(temp_list) <- tools::file_path_sans_ext(basename(chunk_files))
      }
      
      # Crea uno stack temporaneo per questo chunk
      temp_stack <- rast(temp_list)
      
      # Aggiungi al raster stack finale
      if (is.null(final_stack)) {
        final_stack <- temp_stack
      } else {
        final_stack <- c(final_stack, temp_stack)
      }
      
      # Pulizia memoria
      rm(temp_list, temp_stack)
      gc(verbose = FALSE)
    }
    
    return(final_stack)
  
}

raster_stack <- create_raster_stack(raster_files)

species_richness <- sum(raster_stack)
gc()


writeRaster(species_richness, "SCB/results/richness1-80.tif")
species_richness <- rast("SCB/results/richness1-80.tif")
species_richness <- raster(species_richness)
species_density <- species_richness / nlyr(raster_stack)
species_density <- rast(species_density)                                               














create_community_matrix <- function(raster_stack, grid_sf, threshold = 0.5, 
                                  chunk_size = 5, presence_absence = TRUE) {
  total_layers <- nlyr(raster_stack)
  species_names <- names(raster_stack)
  
  print("Creazione della community matrix...")
  
  # Inizializza un dataframe vuoto per la community matrix
  # Ogni riga sarà un pixel della griglia, ogni colonna una specie
  final_matrix <- data.frame(cell_id = grid_sf$cell_id)
  
  # Processa lo stack in chunk per evitare problemi di memoria
  if (total_layers > chunk_size) {
    print(paste("Stack con", total_layers, "layer: elaborazione in chunk per ottimizzare la memoria"))
    
    # Processa i layer in chunk
    for (i in seq(1, total_layers, by = chunk_size)) {
      end_idx <- min(i + chunk_size - 1, total_layers)
      print(paste("Elaborazione chunk", ceiling(i/chunk_size), "di", ceiling(total_layers/chunk_size),
                  "(specie", i, "-", end_idx, ")"))
      
      # Estrai un subset dello stack
      chunk_stack <- subset(raster_stack, i:end_idx)
      chunk_species <- species_names[i:end_idx]
      
      # Estrai dati dal raster per ogni poligono nella griglia
      # Usa la media come metrica per determinare presenza/assenza
      chunk_results <- exact_extract(chunk_stack, grid_sf, fun = "mean", append_cols = "cell_id")
      names(chunk_results) <- gsub("^mean\\.", "", names(chunk_results))

      # Converti a presenza/assenza se richiesto
      if (presence_absence) {
        # Applica la soglia per convertire i valori in presenza (1) o assenza (0)
        chunk_results_pa <- chunk_results
        for (sp in chunk_species) {
          chunk_results_pa[[sp]] <- ifelse(chunk_results[[sp]] > threshold, 1, 0)
        }
        chunk_results <- chunk_results_pa
      }
      
      # Aggiungi i risultati alla matrice finale
      if (ncol(final_matrix) == 1) {
        # Prima iterazione, aggiungi tutte le colonne
        final_matrix <- chunk_results
      } else {
        # Unisci con i risultati precedenti
        final_matrix <- final_matrix %>% 
          left_join(chunk_results, by = "cell_id")
      }
      
      # Pulizia memoria
      rm(chunk_stack, chunk_results)
      if (presence_absence) rm(chunk_results_pa)
      gc(verbose = FALSE)
    }
  } else {
    # Se abbiamo pochi layer, procediamo in un colpo solo
    results <- exact_extract(raster_stack, grid_sf, fun = "mean", append_cols = "cell_id")
    
    # Converti a presenza/assenza se richiesto
    if (presence_absence) {
      for (sp in species_names) {
        results[[sp]] <- ifelse(results[[sp]] > threshold, 1, 0)
      }
    }
    
    final_matrix <- results
  }
  
  # Ordina per cell_id
  final_matrix <- final_matrix %>% arrange(cell_id)
  
  # Restituisci la matrice
  return(final_matrix)
}



community_matrix <- create_community_matrix(
  raster_stack = raster_stack,
  grid_sf = grid_sf,
  threshold = 0.5,  # Modifica questa soglia in base alle tue esigenze
  chunk_size = 5,   # Numero di specie da processare insieme
  presence_absence = TRUE  # TRUE per una matrice binaria (0/1), FALSE per valori continui
)


